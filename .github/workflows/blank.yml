name: Next.js CI/CD
on:
  push:
    tags: v*
  workflow_dispatch:
  # This workflow is reused by multiple workflow triggers:
  # https://docs.github.com/en/actions/using-workflows/reusing-workflows#creating-a-reusable-workflow
permissions:
  id-token: write
  pull-requests: write
  contents: read
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    steps:
      # checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: 'refs/heads/main'
        
      - name: Setup JFrog CLI for SAAS main
        uses: jfrog/setup-jfrog-cli@v4
        id: setup-cli-main
        env:  
          JF_URL: https://incloudmaster.jfrog.io
        with:
          oidc-provider-name: manoj-git
          oidc-audience: manoj

      # Step 2: Set the pnpm store path and save as env var for following steps
      - name: Set and get pnpm store directory
        run: |
          pnpm config set store-dir .pnpm-store
          export STORE_PATH=$(pnpm store path --silent)
          echo "STORE_PATH=${STORE_PATH}" >> $GITHUB_ENV
          mkdir -p "${STORE_PATH}"
          ls -la "${STORE_PATH}"

      # Step 3: Cache the pnpm store when the lock file changes
      - name: Cache pnpm
        uses: actions/cache@v3.3.2
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      # Step 4: Create .env file and export TAG/TAG_* env vars to GITHUB_ENV
      - name: Create .env and TAG file(s)
        id: env
        run: bash ./scripts/env.sh

      # Step 5: Lint, Unit Test, and check for build-time errors
      - name: Lint, Unit Test
        run: |-
          bash ./scripts/install.sh
          bash ./scripts/lint.sh
          bash ./scripts/test.sh
          pnpm build

      # Step 6: Configure JFrog and Docker
      - name: Install Docker
        run: apk add --update docker

      - name: Setup JFrog üê∏ CLI with GitHub OIDC
        uses: jfrog/setup-jfrog-cli@v4
        id: jfrog
        with:
          oidc-provider-name: ${{ vars.JF_OIDC_PROVIDER_NAME }}
          oidc-audience: ${{ vars.JF_OIDC_AUDIENCE }}
        env:
          JF_URL: ${{ vars.JF_URL }}
          JF_LOG_LEVEL: DEBUG
          # Add verbose logging
          CI: true
          DEBUG: "*"


      - name: Log in to Artifactory
        uses: docker/login-action@v2
        with:
          registry: ${{ vars.ARTIFACTORY_HOST }}
          username: ${{ steps.jfrog.outputs.oidc-user }}
          password: ${{ steps.jfrog.outputs.oidc-token }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=${{ vars.ARTIFACTORY_HOST }}/vast-docker/moby/buildkit:buildx-stable-1

      # Step 7: Build Docker image
      - name: Build and Publish Images
        run: bash ./scripts/build.sh

      # Step 8: Publish Docker image
      - name: Build and Publish Images
        if: ${{ inputs.publish == true }}
        run: bash ./scripts/publish.sh
